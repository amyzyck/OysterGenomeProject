library(qvalue)
library(lfmm)
########################################################################
# 
# File    : LFMMwild.R
# History : 2019/03/20 Created by Kevin Freeman (KF) 
# 
#----------------------------------------------------------------------
# This script is used to perform LFMM ridge analysis  for association 
# between genotype and environmental factors in wild type populations. 
# It starts with  a genotype matrix generated by Bodie with 
# populationStructureScript.R and subsets it to only include wild type
# populations
#########################################################################


#////////////////////////////////////////////////////////////////////////
# combineMetadata is a function to combine the metedata from 
# modified_samplemetadata.csv with environmental data from
# full_sample_metadata_4_20_19_ER.csv
#-----------------------------------------------------------------------
# inputs: 
#  - metadata      -- modfied_samplemetadata.csv
#  - envi_metadata -- full_sample_metadata_4_20_19_ER.csv
# outputs:
#  - a dataframe that combines the data from the 2 files
#
#////////////////////////////////////////////////////////////////////////

combineMetadata <- function(metadata, envi_metadata, plot_colors){
  # make the Wild.Sel column match between the two metadata files
  envi_metadata$Wild.Sel[which(envi_metadata$Wild.Sel == "inbred")] <- "I"

  # combine the two metadata csv files
  common_cols <- intersect(names(envi_metadata), names(metadata))
  comb_metadata <-  merge(metadata, 
                          envi_metadata[which(envi_metadata$Sample.ID %in% metadata$Sample.ID), 
                          which(! names(envi_metadata) %in% common_cols[-1])],   # index 1 is Sample.ID, keep that to merge 
                          by = "Sample.ID", all = T)
  comb_metadata <- merge(comb_metadata, plot_colors, by = "custom.id")
  comb_metadata <- comb_metadata[order(comb_metadata$vcf_order), ]
  return(comb_metadata)
}
#///////////////////////////////////////////////////////////////////////////
#
# subsetGenoData uses the combined metadata dataframe to subset
# the genotype data to only include the wild_for_assoc populations
#
#---------------------------------------------------------------------
# inputs: 
#   - geno_data     -- a list object that contains genotype, population IDs,
#                      chromosome numbers, and positions for each SNP
#   - comb_metadata -- a dataframe created by combineMetadata that 
#                      includes a column named "wild_for_assoc" where
#                      a value of 1 indicates that a sample should be 
#                      included and 0 indicates it should be ignored
# outputs:
#   - a new list object that only includes info for the selected samples
#
#///////////////////////////////////////////////////////////////////////////

subsetGenoData <- function(geno_data, comb_metadata){
  # ### Select only Wild populations to rewrite matrix
  print("Selecting wild_for_assoc populations")
  wild           <- geno_data
  wild$G         <- geno_data$G[, which(comb_metadata$wild_for_assoc == 1)]
  wild$Pop.ID    <- geno_data$Pop.ID[which(comb_metadata$wild_for_assoc == 1)]
  wild$Sample.ID <- geno_data$Sample.ID[which(comb_metadata$wild_for_assoc == 1)]
   
  # The genotype matrix has some fixed values, remove them before proceeding
  print("Removing fixed sites")
  variances <- apply(wild$G, 1, var)
  not_fixed <- variances > 0
  wild$G <- wild$G[not_fixed, ]
  #  update the positions and chr
  wild$Pos <- wild$Pos[not_fixed]
  wild$Chr <- wild$Chr[not_fixed]
 
  ### Save the new genotype matrix for quicker future analysis
  print("Saving 'data/genotypeMatrix_selecting_Wild.rds'")
  saveRDS(wild, paste("data", "genotypeMatrix_selecting_Wild.rds", sep="/"))
  return(wild)
}

#//////////////////////////////////////////////////////////////////////////////////
#
# calcEnviLFMMandSpRho does the bulk of the analysis. It calculates LFMM 
# p-values and Spearmann's Rho for the association between genotype and the 
# given environmental variable. Optionally, it produces plots to visualize 
# the results. It always saves the results in a dataframe with descriptive
# column names. 
# ---------------------------------------------------------------------------------
# Inputs: 
#        - envi_var   -- the name of the environmental variable to consider. Must
#                        match the name of one of the columns in metadata
#        - pop_object -- a list object of the type created by subsetGenoData,
#                        contains genotypes and pop IDs
#        - metadata   -- the metadata file that contains environmental variables
#                        and pop IDs
#        - plots      -- a boolean: TRUE means create plots, FALSE means only create
#                        the dataframe        
# Outputs: 
#       - a dataframe with columns for spearmann's rho values,  LFMM values, Chr,
#         Pos, and "Unique" (an identifier created from Chr and Pos)
#       - optional : plots that have been saved in figures/6envi_assoc
#///////////////////////////////////////////////////////////////////////////////////

calcEnviLFMMandSpRho <- function(envi_var, pop_object, metadata, plots){
  # scale genotype matrix
  scaled.genotype <- scale(as.matrix(t(pop_object$G)))
  # create a temperature matrix
  envi        <- metadata[envi_var]
  envi        <- envi[which(metadata$wild_for_assoc == 1), ]
  envi_matrix <- matrix(data = envi, nrow = length(envi), ncol = 1)
  scaled.envi <- scale(envi_matrix)
  
  # build lfmm ridge model
  print("Building lfmm ridge model")
  lfmm.ridge <- lfmm::lfmm_ridge(Y = scaled.genotype, X = scaled.envi, K = 3, lambda = 1e-4)
  # perform association testing
  print("Running lfmm test")
  lfmm.test.ridge <- lfmm::lfmm_test(Y = scaled.genotype, X = scaled.envi, lfmm = lfmm.ridge, calibrate = "gif")
  
  # get p values
  p.values.ridge <- lfmm.test.ridge$calibrated.pvalue
  print(c("lfmm.test.ridge$gif", lfmm.test.ridge$gif))
  
  
  # spearman's correlation
  print("Calculating spearman's correlation")
  absSpCor <- abs(cor(scaled.envi, scaled.genotype, method = "spearman"))
  
  if (plots){
    ### LF Pplot
    print("Plotting LF 1 and 2")
    png(paste("figures/6envi_assoc/LFMM_ridge_0.0", envi_var, "LF_plot.png", sep = "_"))
    plot(lfmm.ridge$U[,1], lfmm.ridge$U[,2], col = metadata[which(metadata$wild_for_assoc == 1),]$color, pch = 19, 
         main = paste("LFMM Ridge", envi_var,"Association"), xlab = "LF1", ylab = "LF2")
    text(lfmm.ridge$U[,1], lfmm.ridge$U[,2] + 20, labels = pop_object$Pop.ID, cex = 0.6)
    dev.off()
    rm(lfmm.test.ridge)
    rm(lfmm.ridge)

    # LFMM p-value plot
    LFMM_ridge_0.0_log10p <- -log10(as.numeric(p.values.ridge))
    rm(p.values.ridge)
    png(paste("figures/6envi_assoc/LFMM_ridge_0.0", envi_var, "pvalues_plot.png", sep = "_"))
    plot(pop_object$Pos, LFMM_ridge_0.0_log10p, main = "LFMM Ridge P-values")
    dev.off()
    
    # Spearmann's vs LFMM
    png(paste("figures/6envi_assoc/Spearmanns_vs_LFMM", envi_var, "plot.png", sep = "_"))
    plot(absSpCor, LFMM_ridge_0.0_log10p, main = "Spearmann's Rho vs LFMM Ridge")
    abline(lm(LFMM_ridge_0.0_log10p ~ as.vector(absSpCor)), col = "red")
    dev.off()
  }
  
  ### Save the results
  print("Creating data frame")
  unique_ID <- sprintf("%02d_%09d", pop_object$Chr, pop_object$Pos)
  # make data into a matrix
  stat_matrix <- matrix(c(pop_object$Pos, pop_object$Chr, unique_ID, 
		     LFMM_ridge_0.0_log10p, absSpCor), ncol = 5, nrow = length(unique_ID))
  # matrix to dataframe
  out_table <- as.data.frame(stat_matrix)
  # rename columns
  colnames(out_table) <- c("Pos", "Chr", "Unique", 
			   paste("LFMM_ridge_0.0_log10p", envi_var, "wild_for_assoc",sep = "_"),
                           paste("Spearmanns_Rho_ABS", envi_var, "wild_for_assoc", sep = "_"))
  return(out_table)
}

#### Read in and process the data
all_data        <- readRDS("data/large_data/genotypeMatrix.rds")
print("Reading and processing metadata")
metadata       <- read.csv("data/modified_samplemetadata.csv", stringsAsFactors = FALSE, header = TRUE)
envi_metadata  <- read.csv("data/environment/full_sample_metadata_4_20_19_ER.csv", stringsAsFactors = FALSE, header = TRUE)
plot_metadata  <- read.csv("data/PopPlotting_COLORS.csv", stringsAsFactors = FALSE, header = TRUE)

all_metadata <- combineMetadata(metadata = metadata, envi_metadata = envi_metadata, plot_colors = plot_metadata)

#wild <- subsetGenoData(all_data, all_metadata)
wild <- readRDS("data/genotypeMatrix_selecting_Wild.rds")

# quick check

print(paste0("Wild Sample.ID matches metadata Sample.ID? --- ", identical(wild$Sample.ID, all_metadata$Sample.ID[which(all_metadata$wild_for_assoc == 1)])))
if (! identical(wild$Sample.ID, all_metadata$Sample.ID[which(all_metadata$wild_for_assoc == 1)])){
  stop("Genotype matrix and metadata don't match")
}


### Make a scree plot to identify the K value to use
print("plotting PCA scree plot")
png("figures/6envi_assoc/PCA_scree_plot.png")
PCA <- prcomp(wild$G)
plot(PCA, type = "l", main = "PCA Scree Plot")
dev.off()

## Calc statistics and generate plots

envi_variables <- c("Max_temperature_Celsius", "Min_temperature_Celsius",
                    "Mean_Annual_Salinity_ppt", "dd_0", "dd_30")

#"Lat","Long", "Temp_C", "Mean_Annual_Temperature_Celsius", 

for (var in envi_variables){
  message("----------------------------------------------------")
  message(paste0("STARTING ANALYSIS FOR: ", var))
  message("----------------------------------------------------")
  
  out_table <- calcEnviLFMMandSpRho(envi_var = var, pop_object = wild, metadata = all_metadata, plots = TRUE)
  print("saving dataframe")
  if (!dir.exists("data/envi_assoc_results")){
    dir.create("data/envi_assoc_results")
  }
  write.table(out_table, file = paste0("data/envi_assoc_results/", var, "_assoc_results.txt"), 
              quote = FALSE, sep = "\t", row.names = FALSE)
}

